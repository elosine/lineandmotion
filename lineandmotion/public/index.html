 <!DOCTYPE html>
 <html lang="en">

 <head>
   <title>Line & Motion</title>
   <meta charset="utf-8">
   <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
   <link type="text/css" rel="stylesheet" href="main.css">
   <link rel="stylesheet" type="text/css" href="lmstylesheet.css">
 </head>

 <body>
   <div id='tlcanvas'></div>

   <!-- This is the 'compute shader' for the water heightmap: -->
   <script id="heightmapFragmentShader" type="x-shader/x-fragment">

     #include <common>

     uniform vec2 rp0;
     uniform vec2 rp1;
      uniform vec2 rp2;
      uniform vec2 rp3;
      uniform vec2 rp4;
      uniform vec2 rp5;
      uniform vec2 rp6;
      uniform vec2 rp7;
      uniform vec2 rp8;
      uniform vec2 rp9;
      uniform vec2 rp10;
			uniform vec2 rp11;
      uniform vec2 rp12;
      uniform vec2 rp13;
      uniform vec2 rp14;
      uniform vec2 rp15;
      uniform vec2 rp16;
      uniform vec2 rp17;
      uniform vec2 rp18;
      uniform vec2 rp19;
      uniform vec2 rp20;
			uniform vec2 rp21;
      uniform vec2 rp22;
      uniform vec2 rp23;
      uniform vec2 rp24;
      uniform vec2 rp25;
      uniform vec2 rp26;
      uniform vec2 rp27;
      uniform vec2 rp28;
      uniform vec2 rp29;
      uniform vec2 rp30;
			uniform float mouseSize;
			uniform float viscosityConstant;
			uniform float heightCompensation;

			void main()	{
				vec2 cellSize = 1.0 / resolution.xy;
				vec2 uv = gl_FragCoord.xy * cellSize;
				vec4 heightmapValue = texture2D( heightmap, uv );
				// Get neighbours
				vec4 north = texture2D( heightmap, uv + vec2( 0.0, cellSize.y ) );
				vec4 south = texture2D( heightmap, uv + vec2( 0.0, - cellSize.y ) );
				vec4 east = texture2D( heightmap, uv + vec2( cellSize.x, 0.0 ) );
				vec4 west = texture2D( heightmap, uv + vec2( - cellSize.x, 0.0 ) );
				// https://web.archive.org/web/20080618181901/http://freespace.virgin.net/hugo.elias/graphics/x_water.htm
				float newHeight = ( ( north.x + south.x + east.x + west.x ) * 0.5 - heightmapValue.y ) * viscosityConstant;

				// Mouse influence
				float rpph0 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp0.x, - rp0.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph0 ) + 1.0 ) * 0.28;
				float rpph1 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp1.x, - rp1.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph1 ) + 1.0 ) * 0.28;
        float rpph2 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp2.x, - rp2.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph2 ) + 1.0 ) * 0.28;
        float rpph3 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp3.x, - rp3.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph3 ) + 1.0 ) * 0.28;
        float rpph4 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp4.x, - rp4.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph4 ) + 1.0 ) * 0.28;
        float rpph5 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp5.x, - rp5.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph5 ) + 1.0 ) * 0.28;
        float rpph6 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp6.x, - rp6.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph6 ) + 1.0 ) * 0.28;
        float rpph7 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp7.x, - rp7.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph7 ) + 1.0 ) * 0.28;
        float rpph8 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp8.x, - rp8.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph8 ) + 1.0 ) * 0.28;
        float rpph9 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp9.x, - rp9.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph9 ) + 1.0 ) * 0.28;
        float rpph10 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp10.x, - rp10.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph10 ) + 1.0 ) * 0.28;

				heightmapValue.y = heightmapValue.x;
				heightmapValue.x = newHeight;

				gl_FragColor = heightmapValue;


			}

		</script>


   <!-- This is just a smoothing 'compute shader' for using manually: -->
   <script id="smoothFragmentShader" type="x-shader/x-fragment">

     uniform sampler2D smoothTexture;

			void main()	{

				vec2 cellSize = 1.0 / resolution.xy;

				vec2 uv = gl_FragCoord.xy * cellSize;

				// Computes the mean of texel and 4 neighbours
				vec4 textureValue = texture2D( smoothTexture, uv );
				textureValue += texture2D( smoothTexture, uv + vec2( 0.0, cellSize.y ) );
				textureValue += texture2D( smoothTexture, uv + vec2( 0.0, - cellSize.y ) );
				textureValue += texture2D( smoothTexture, uv + vec2( cellSize.x, 0.0 ) );
				textureValue += texture2D( smoothTexture, uv + vec2( - cellSize.x, 0.0 ) );

				textureValue /= 5.0;

				gl_FragColor = textureValue;

			}

		</script>

   <!-- This is a 'compute shader' to read the current level and normal of water at a point -->
   <!-- It is used with a variable of size 1x1 -->
   <script id="readWaterLevelFragmentShader" type="x-shader/x-fragment">

     uniform vec2 point1;

			uniform sampler2D levelTexture;

			// Integer to float conversion from https://stackoverflow.com/questions/17981163/webgl-read-pixels-from-floating-point-render-target

			float shift_right( float v, float amt ) {

				v = floor( v ) + 0.5;
				return floor( v / exp2( amt ) );

			}

			float shift_left( float v, float amt ) {

				return floor( v * exp2( amt ) + 0.5 );

			}

			float mask_last( float v, float bits ) {

				return mod( v, shift_left( 1.0, bits ) );

			}

			float extract_bits( float num, float from, float to ) {

				from = floor( from + 0.5 ); to = floor( to + 0.5 );
				return mask_last( shift_right( num, from ), to - from );

			}

			vec4 encode_float( float val ) {
				if ( val == 0.0 ) return vec4( 0, 0, 0, 0 );
				float sign = val > 0.0 ? 0.0 : 1.0;
				val = abs( val );
				float exponent = floor( log2( val ) );
				float biased_exponent = exponent + 127.0;
				float fraction = ( ( val / exp2( exponent ) ) - 1.0 ) * 8388608.0;
				float t = biased_exponent / 2.0;
				float last_bit_of_biased_exponent = fract( t ) * 2.0;
				float remaining_bits_of_biased_exponent = floor( t );
				float byte4 = extract_bits( fraction, 0.0, 8.0 ) / 255.0;
				float byte3 = extract_bits( fraction, 8.0, 16.0 ) / 255.0;
				float byte2 = ( last_bit_of_biased_exponent * 128.0 + extract_bits( fraction, 16.0, 23.0 ) ) / 255.0;
				float byte1 = ( sign * 128.0 + remaining_bits_of_biased_exponent ) / 255.0;
				return vec4( byte4, byte3, byte2, byte1 );
			}

			void main()	{

				vec2 cellSize = 1.0 / resolution.xy;

				float waterLevel = texture2D( levelTexture, point1 ).x;

				vec2 normal = vec2(
					( texture2D( levelTexture, point1 + vec2( - cellSize.x, 0 ) ).x - texture2D( levelTexture, point1 + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
					( texture2D( levelTexture, point1 + vec2( 0, - cellSize.y ) ).x - texture2D( levelTexture, point1 + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS );

				if ( gl_FragCoord.x < 1.5 ) {

					gl_FragColor = encode_float( waterLevel );

				} else if ( gl_FragCoord.x < 2.5 ) {

					gl_FragColor = encode_float( normal.x );

				} else if ( gl_FragCoord.x < 3.5 ) {

					gl_FragColor = encode_float( normal.y );

				} else {

					gl_FragColor = encode_float( 0.0 );

				}

			}

		</script>

   <!-- This is the water visualization shader, copied from the THREE.MeshPhongMaterial and modified: -->
   <script id="waterVertexShader" type="x-shader/x-vertex">

     uniform sampler2D heightmap;

			#define PHONG

			varying vec3 vViewPosition;

			#ifndef FLAT_SHADED

				varying vec3 vNormal;

			#endif

			#include <common>
			#include <uv_pars_vertex>
			#include <uv2_pars_vertex>
			#include <displacementmap_pars_vertex>
			#include <envmap_pars_vertex>
			#include <color_pars_vertex>
			#include <morphtarget_pars_vertex>
			#include <skinning_pars_vertex>
			#include <shadowmap_pars_vertex>
			#include <logdepthbuf_pars_vertex>
			#include <clipping_planes_pars_vertex>

			void main() {

				vec2 cellSize = vec2( 1.0 / WIDTH, 1.0 / WIDTH );

				#include <uv_vertex>
				#include <uv2_vertex>
				#include <color_vertex>

				// # include <beginnormal_vertex>
				// Compute normal from heightmap
				vec3 objectNormal = vec3(
					( texture2D( heightmap, uv + vec2( - cellSize.x, 0 ) ).x - texture2D( heightmap, uv + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
					( texture2D( heightmap, uv + vec2( 0, - cellSize.y ) ).x - texture2D( heightmap, uv + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS,
					1.0 );
				//<beginnormal_vertex>

				#include <morphnormal_vertex>
				#include <skinbase_vertex>
				#include <skinnormal_vertex>
				#include <defaultnormal_vertex>

			#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

				vNormal = normalize( transformedNormal );

			#endif

				//# include <begin_vertex>
				float heightValue = texture2D( heightmap, uv ).x;
				vec3 transformed = vec3( position.x, position.y, heightValue );
				//<begin_vertex>

				#include <morphtarget_vertex>
				#include <skinning_vertex>
				#include <displacementmap_vertex>
				#include <project_vertex>
				#include <logdepthbuf_vertex>
				#include <clipping_planes_vertex>

				vViewPosition = - mvPosition.xyz;

				#include <worldpos_vertex>
				#include <envmap_vertex>
				#include <shadowmap_vertex>

			}

		</script>


   <script type="module">
      import * as THREE from '../build/three.module.js';
		  import { GPUComputationRenderer } from './jsm/misc/GPUComputationRenderer.js';
			import { SimplexNoise } from './jsm/math/SimplexNoise.js';
      // GLOBAL VARIABLES ------------------------------------- //
      //TIMING & ANIMATION ENGINE /////////////
      var frmRate = 60.0;
      var framect = 0;
      var delta = 0.0;
      var lastFrameTimeMs = 0.0;
      var timestep = 1000.0 / frmRate;
      var pieceClock = 0.0;
      var clockadj = 0.0;
      var timeToGo = 3.0;
      var pxPerSec = 100.0;
      var pxPerFrame = pxPerSec / frmRate;
      var pxPerMs = pxPerSec / 1000.0;
      //COLORS /////////////////////////////////
      var clr_limegreen = new THREE.Color("rgb(153, 255, 0)");
      var clr_yellow = new THREE.Color("rgb(255, 255, 0)");
      var clr_orange = new THREE.Color("rgb(255, 128, 0)");
			// Texture width for simulation
      var WIDTH = 196;
			// Water size in system units
      var BOUNDS = 512;
      var BOUNDSL = 512;
			var BOUNDS_HALF = BOUNDS * 0.5;

      var CW = 560;
      var CH = 520;

			var container;
			var camera, scene, renderer;

			var waterMesh;
			var gpuCompute;
			var heightmapVariable;
			var waterUniforms;
			var smoothShader;
			var readWaterLevelShader;
			var readWaterLevelRenderTarget;
			var readWaterLevelImage;
			var waterNormal = new THREE.Vector3();
			var simplex = new SimplexNoise();
      //GO FRETS ///////////////////////////////
      var gofretposx = -120;
      var gofretposz = 247;
      //TEMPO FRETS ///////////////////////////////
      var gofret1, tfbgeom, tfbmatl, gofretborder;
      var tfs = [];
      var gofretTimer = 0;
      var tfgeom = new THREE.CubeGeometry(30, 60, 5);
      var gofretGeomBig = new THREE.CubeGeometry(14, 64, 13);
      var tfbgeom = new THREE.EdgesGeometry(tfgeom);
      var tfbgeomBig = new THREE.EdgesGeometry(gofretGeomBig);
      var gfmatl = new THREE.MeshBasicMaterial({
        color: "rgb(255,255,0)"
      });
      var tfmatl = new THREE.MeshBasicMaterial({
        color: "rgb(255,128,0)"
      });

			init();
      requestAnimationFrame(mainLoop);

			function init() {
        container = document.getElementById('tlcanvas');
        camera = new THREE.PerspectiveCamera( 75, CW / CH, 1, 3000 );
        camera.position.set( 0, 350, 350 );
        camera.rotation.x = rads(-48);

				scene = new THREE.Scene();

				var sun = new THREE.DirectionalLight( 0xFFFFFF, 1.0 );
				sun.position.set( 300, 400, 175 );
				scene.add( sun );

				var sun2 = new THREE.DirectionalLight( 0x40A040, 0.6 );
				sun2.position.set( - 100, 350, - 200 );
				scene.add( sun2 );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( CW, CH );
				container.appendChild( renderer.domElement );

				initWater();

        // Back Plane
        var planeMaterial =
          new THREE.MeshLambertMaterial({
            color: 0x0040C0
          });
        var plane = new THREE.Mesh(
          new THREE.PlaneGeometry(
            512,
            800,
            10,
            10
          ),
          planeMaterial
        );
        plane.position.z = -640;
        plane.rotation.x = -90 * Math.PI / 180;
        scene.add(plane);
        //TRACKS ///////////////////////////////////////////
        var cygeom = new THREE.CylinderGeometry(5, 5, 1200, 32);
        var cymatl = new THREE.MeshLambertMaterial({color: 0x708090});
        var cy1 = new THREE.Mesh(cygeom, cymatl);
        var cy2 = new THREE.Mesh(cygeom, cymatl);
        var cy3 = new THREE.Mesh(cygeom, cymatl);
        var cy4 = new THREE.Mesh(cygeom, cymatl);
        cy1.rotation.x = -90 * Math.PI / 180;
        cy1.position.z = -346;
        cy2.rotation.x = -90 * Math.PI / 180;
        cy2.position.z = -346;
        cy1.position.x = -40;
        cy2.position.x = 40;
        cy3.rotation.x = -90 * Math.PI / 180;
        cy3.position.z = -346;
        cy4.rotation.x = -90 * Math.PI / 180;
        cy4.position.z = -346;
        cy3.position.x = -120;
        cy4.position.x = 120;
        scene.add(cy1);
        scene.add(cy2);
        scene.add(cy3);
        scene.add(cy4);
        //GO FRETS ///////////////////////////////////////////
        gofret1 = new THREE.Mesh(tfgeom, gfmatl);
        gofret1.position.x = -120;
        gofret1.position.z = gofretposz;
        gofret1.rotation.z = -90 * Math.PI / 180;
        scene.add(gofret1);
        var gofret2 = new THREE.Mesh(tfgeom, gfmatl);
        gofret2.position.x = -40;
        gofret2.position.z = gofretposz;
        gofret2.rotation.z = -90 * Math.PI / 180;
        scene.add(gofret2);
        var gofret3 = new THREE.Mesh(tfgeom, gfmatl);
        gofret3.position.x = 40;
        gofret3.position.z = gofretposz;
        gofret3.rotation.z = -90 * Math.PI / 180;
        scene.add(gofret3);
        var gofret4 = new THREE.Mesh(tfgeom, gfmatl);
        gofret4.position.x = 120;
        gofret4.position.z = gofretposz;
        gofret4.rotation.z = -90 * Math.PI / 180;
        scene.add(gofret4);
        // ADD TEMPO FRETS
        //given start time, tempo, #beats, get destination frame
        var itfstarttime = 3;
        var tempo = 60.0;
        var numbeats = 52;
        //durpx = initialstarttime*pxPerSec
        //startpx = durpx + gofretposx
        //durframes = durpx/pxPerFrame
        //destination frame = framect + durframes
        var durpx = itfstarttime * pxPerSec;
        var istartpx = gofretposz - durpx;
        var idurframes = durpx / pxPerFrame;
        var igoframe = Math.round(framect + idurframes);
        //igoframe + dur of beat in frames
        //pause at destination, print framect, destination frame, position.x
        for (var i = 0; i < numbeats; i++) {
          //Add orange fret and move
          var tft = new THREE.Mesh(tfgeom, tfmatl);
          var pxPerBeat = pxPerSec / (tempo / 60);
          var startpx = istartpx - (pxPerBeat * i);
          var goframe = Math.round(igoframe + ((pxPerBeat / pxPerFrame) * i));
          tft.rotation.z = -90 * Math.PI / 180;
          tft.position.z = startpx;
          tft.position.x = gofretposx;
          tft.name = "tft" + i;
          /* [
          boolean:add (so it is added to the scene only once),
          tft: tempo fret mesh,
          goframe
          ] */

          var ntft = [true, tft, goframe];
          tfs.push(ntft);
        }
        heightmapVariable.material.uniforms[ "mouseSize" ].value = 10;
        heightmapVariable.material.uniforms[ "viscosityConstant" ].value = 0.996;

        smoothWater();
			}


			function initWater() {
				var materialColor = 0x0040C0;
				var geometry = new THREE.PlaneBufferGeometry( BOUNDS, BOUNDSL, WIDTH - 1, WIDTH - 1 );
				// material: make a THREE.ShaderMaterial clone of THREE.MeshPhongMaterial, with customized vertex shader
				var material = new THREE.ShaderMaterial( {
					uniforms: THREE.UniformsUtils.merge( [
						THREE.ShaderLib[ 'phong' ].uniforms,
						{
							"heightmap": { value: null }
						}
					] ),
					vertexShader: document.getElementById( 'waterVertexShader' ).textContent,
					fragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]

				} );
				material.lights = true;
				// Material attributes from THREE.MeshPhongMaterial
				material.color = new THREE.Color( materialColor );
				material.specular = new THREE.Color( 0x111111 );
				material.shininess = 50;
				// Sets the uniforms with the material values
				material.uniforms[ "diffuse" ].value = material.color;
				material.uniforms[ "specular" ].value = material.specular;
				material.uniforms[ "shininess" ].value = Math.max( material.shininess, 1e-4 );
				material.uniforms[ "opacity" ].value = material.opacity;
				// Defines
				material.defines.WIDTH = WIDTH.toFixed( 1 );
				material.defines.BOUNDS = BOUNDS.toFixed( 1 );
				material.defines.BOUNDSL = BOUNDSL.toFixed( 1 );
				waterUniforms = material.uniforms;
				waterMesh = new THREE.Mesh( geometry, material );
				waterMesh.rotation.x = - Math.PI / 2;
				waterMesh.matrixAutoUpdate = false;
				waterMesh.updateMatrix();
				scene.add( waterMesh );
				// Creates the gpu computation class and sets it up
				gpuCompute = new GPUComputationRenderer( WIDTH, WIDTH, renderer );
				var heightmap0 = gpuCompute.createTexture();
				fillTexture( heightmap0 );
				heightmapVariable = gpuCompute.addVariable( "heightmap", document.getElementById( 'heightmapFragmentShader' ).textContent, heightmap0 );
				gpuCompute.setVariableDependencies( heightmapVariable, [ heightmapVariable ] );
				heightmapVariable.material.uniforms[ "rp0" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp1" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp2" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp3" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp4" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp5" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp6" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp7" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp8" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp9" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp10" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "mouseSize" ] = { value: 20.0 };
				heightmapVariable.material.uniforms[ "viscosityConstant" ] = { value: 0.98 };
				heightmapVariable.material.uniforms[ "heightCompensation" ] = { value: 0 };
				heightmapVariable.material.defines.BOUNDS = BOUNDS.toFixed( 1 );
				heightmapVariable.material.defines.BOUNDSL = BOUNDSL.toFixed( 1 );
				var error = gpuCompute.init();
				if ( error !== null ) {
				    console.error( error );
				}
				// Create compute shader to smooth the water surface and velocity
				smoothShader = gpuCompute.createShaderMaterial( document.getElementById( 'smoothFragmentShader' ).textContent, { smoothTexture: { value: null } } );
				// Create compute shader to read water level
				readWaterLevelShader = gpuCompute.createShaderMaterial( document.getElementById( 'readWaterLevelFragmentShader' ).textContent, {
					point1: { value: new THREE.Vector2() },
					levelTexture: { value: null }
				} );
				readWaterLevelShader.defines.WIDTH = WIDTH.toFixed( 1 );
				readWaterLevelShader.defines.BOUNDS = BOUNDS.toFixed( 1 );
				readWaterLevelShader.defines.BOUNDSL = BOUNDSL.toFixed( 1 );
				// Create a 4x1 pixel image and a render target (Uint8, 4 channels, 1 byte per channel) to read water height and orientation
				readWaterLevelImage = new Uint8Array( 4 * 1 * 4 );
				readWaterLevelRenderTarget = new THREE.WebGLRenderTarget( 4, 1, {
					wrapS: THREE.ClampToEdgeWrapping,
					wrapT: THREE.ClampToEdgeWrapping,
					minFilter: THREE.NearestFilter,
					magFilter: THREE.NearestFilter,
					format: THREE.RGBAFormat,
					type: THREE.UnsignedByteType,
					stencilBuffer: false,
					depthBuffer: false
				} );
			}

			function fillTexture( texture ) {
				var waterMaxHeight = 10;
				function noise( x, y ) {
					var multR = waterMaxHeight;
					var mult = 0.025;
					var r = 0;
					for ( var i = 0; i < 15; i ++ ) {
						r += multR * simplex.noise( x * mult, y * mult );
						multR *= 0.53 + 0.025 * i;
						mult *= 1.25;
					}
					return r;
				}
				var pixels = texture.image.data;
				var p = 0;
				for ( var j = 0; j < WIDTH; j ++ ) {
					for ( var i = 0; i < WIDTH; i ++ ) {
						var x = i * 128 / WIDTH;
						var y = j * 128 / WIDTH;
						pixels[ p + 0 ] = noise( x, y );
						pixels[ p + 1 ] = pixels[ p + 0 ];
						pixels[ p + 2 ] = 0;
						pixels[ p + 3 ] = 1;
						p += 4;
					}
				}
			}

			function smoothWater() {
				var currentRenderTarget = gpuCompute.getCurrentRenderTarget( heightmapVariable );
				var alternateRenderTarget = gpuCompute.getAlternateRenderTarget( heightmapVariable );
				for ( var i = 0; i < 10; i ++ ) {
					smoothShader.uniforms[ "smoothTexture" ].value = currentRenderTarget.texture;
					gpuCompute.doRenderTarget( smoothShader, alternateRenderTarget );
					smoothShader.uniforms[ "smoothTexture" ].value = alternateRenderTarget.texture;
					gpuCompute.doRenderTarget( smoothShader, currentRenderTarget );
				}
			}

      // function sphereDynamics() {
  		// 		var currentRenderTarget = gpuCompute.getCurrentRenderTarget( heightmapVariable );
  		// 		readWaterLevelShader.uniforms[ "levelTexture" ].value = currentRenderTarget.texture;
  		// 		for ( var i = 0; i < tfs.length; i ++ ) {
  		// 			var obj = tfs[i][1];
  		// 			if ( obj ) {
  		// 				// Read water level and orientation
  		// 				var u = 0.5 * obj.position.x / BOUNDS_HALF + 0.5;
  		// 				var v = 1 - ( 0.5 * obj.position.z / BOUNDS_HALF + 0.5 );
  		// 				readWaterLevelShader.uniforms[ "point1" ].value.set( u, v );
  		// 				gpuCompute.doRenderTarget( readWaterLevelShader, readWaterLevelRenderTarget );
  		// 				renderer.readRenderTargetPixels( readWaterLevelRenderTarget, 0, 0, 4, 1, readWaterLevelImage );
  		// 				var pixels = new Float32Array( readWaterLevelImage.buffer );
  		// 				// Get orientation
  		// 				waterNormal.set( pixels[ 1 ], 0, - pixels[ 2 ] );
  		// 				var pos = obj.position;
  		// 				// Set height
  		// 				pos.y = pixels[ 0 ];
      //       }
      //     }
      // }

      // ANIMATION ENGINE -------------------------------------------- //
      function mainLoop(timestamp) {
        delta += timestamp - lastFrameTimeMs;
        lastFrameTimeMs = timestamp;
        while (delta >= timestep) {
          update(timestep);
          delta -= timestep;
        }
        render();
        requestAnimationFrame(mainLoop);
      }

			function render() {
          // Set uniforms: mouse interaction
          var uniforms = heightmapVariable.material.uniforms;
          for(var i=0;i<tfs.length;i++){
            if(i<11){
              var rpname = "rp" + i;
              uniforms[ rpname ].value.set(-120, tfs[i][1].position.z );
            }
          }
  				// Do the gpu computation
  				gpuCompute.compute();
          // sphereDynamics();
  				// Get compute output in custom uniform
  				waterUniforms[ "heightmap" ].value = gpuCompute.getCurrentRenderTarget( heightmapVariable ).texture;

				// Render
				renderer.render( scene, camera );

			}

      // UPDATE ------------------------------------------------------ //
      function update(timestep) {
        framect++;
        //Clock //////////////////////////////////
        pieceClock += timestep;
        pieceClock = pieceClock - clockadj;
        //Tempo FRETS /////////////////////////////
        for (var i = 0; i < tfs.length; i++) { //if it has not reached go fret
          if (tfs[i][1].position.z < gofretposz) {
            tfs[i][1].position.z += pxPerFrame;
          }
          //add the tf to the scene if it is in the scene
          if (tfs[i][1].position.z > -1000) {
            if (tfs[i][0]) { //gate so the tf is only added to the scene once
              tfs[i][0] = false;
              scene.add(tfs[i][1]);
            }
          }
          if (framect == tfs[i][2]) { //when the tf reaches its destination frame
            // set gofretTimer so it blinks clr_limegreen
            gofretTimer = framect + 12;
            //remove tf from scene and array
            scene.remove(scene.getObjectByName(tfs[i][1].name));
            tfs.splice(i, 1);
          }
        }
        //GO FRET /////////////////////////////////
        if (framect >= gofretTimer) {
          gofret1.material.color = clr_yellow;
          gofret1.geometry = tfgeom;
        } else {
          gofret1.material.color = clr_limegreen;
          gofret1.geometry = gofretGeomBig;
        }
      }

      function rads(deg) {
        return (deg * Math.PI) / 180;
      }

      function map_range(value, low1, high1, low2, high2) {
        return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
      }

		</script>
 </body>

 </html>
