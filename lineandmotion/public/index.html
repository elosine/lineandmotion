 <!DOCTYPE html>
 <html lang="en">

 <head>
   <title>Line & Motion</title>
   <meta charset="utf-8">
   <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
   <link type="text/css" rel="stylesheet" href="main.css">
   <link rel="stylesheet" type="text/css" href="lmstylesheet.css">
 </head>

 <body>
   <div id='tlcanvas'></div>

   <!-- This is the 'compute shader' for the water heightmap: -->
   <script id="heightmapFragmentShader" type="x-shader/x-fragment">

      #include <common>

      uniform vec2 rp0;
      uniform vec2 rp1;
      uniform vec2 rp2;
      uniform vec2 rp3;
      uniform vec2 rp4;
      uniform vec2 rp5;
      uniform vec2 rp6;
      uniform vec2 rp7;
      uniform vec2 rp8;
      uniform vec2 rp9;
      uniform vec2 rp10;

      uniform vec2 rpA0;
      uniform vec2 rpA1;
      uniform vec2 rpA2;
      uniform vec2 rpA3;
      uniform vec2 rpA4;
      uniform vec2 rpA5;
      uniform vec2 rpA6;
      uniform vec2 rpA7;
      uniform vec2 rpA8;
      uniform vec2 rpA9;
      uniform vec2 rpA10;
      uniform vec2 rpB0;
      uniform vec2 rpB1;
      uniform vec2 rpB2;
      uniform vec2 rpB3;
      uniform vec2 rpB4;
      uniform vec2 rpB5;
      uniform vec2 rpB6;
      uniform vec2 rpB7;
      uniform vec2 rpB8;
      uniform vec2 rpB9;
      uniform vec2 rpB10;
      uniform vec2 rpC0;
      uniform vec2 rpC1;
      uniform vec2 rpC2;
      uniform vec2 rpC3;
      uniform vec2 rpC4;
      uniform vec2 rpC5;
      uniform vec2 rpC6;
      uniform vec2 rpC7;
      uniform vec2 rpC8;
      uniform vec2 rpC9;
      uniform vec2 rpC10;

      uniform vec2 rpg0;
      uniform vec2 rpg1;
      uniform vec2 rpg2;
      uniform vec2 rpg3;
      uniform vec2 rpg4;
      uniform vec2 rpg5;
      uniform vec2 rpg6;
      uniform vec2 rpg7;
      uniform vec2 rpg8;
      uniform vec2 rpg9;
      uniform vec2 rpg10;
      uniform vec2 rpgA0;
      uniform vec2 rpgA1;
      uniform vec2 rpgA2;
      uniform vec2 rpgA3;
      uniform vec2 rpgA4;
      uniform vec2 rpgA5;
      uniform vec2 rpgA6;
      uniform vec2 rpgA7;
      uniform vec2 rpgA8;
      uniform vec2 rpgA9;
      uniform vec2 rpgA10;
      uniform vec2 rpgB0;
      uniform vec2 rpgB1;
      uniform vec2 rpgB2;
      uniform vec2 rpgB3;
      uniform vec2 rpgB4;
      uniform vec2 rpgB5;
      uniform vec2 rpgB6;
      uniform vec2 rpgB7;
      uniform vec2 rpgB8;
      uniform vec2 rpgB9;
      uniform vec2 rpgB10;
      uniform vec2 rpgC0;
      uniform vec2 rpgC1;
      uniform vec2 rpgC2;
      uniform vec2 rpgC3;
      uniform vec2 rpgC4;
      uniform vec2 rpgC5;
      uniform vec2 rpgC6;
      uniform vec2 rpgC7;
      uniform vec2 rpgC8;
      uniform vec2 rpgC9;
      uniform vec2 rpgC10;
			uniform float mouseSize;
			uniform float viscosityConstant;
			uniform float heightCompensation;

			void main()	{
				vec2 cellSize = 1.0 / resolution.xy;
				vec2 uv = gl_FragCoord.xy * cellSize;
				vec4 heightmapValue = texture2D( heightmap, uv );
				// Get neighbours
				vec4 north = texture2D( heightmap, uv + vec2( 0.0, cellSize.y ) );
				vec4 south = texture2D( heightmap, uv + vec2( 0.0, - cellSize.y ) );
				vec4 east = texture2D( heightmap, uv + vec2( cellSize.x, 0.0 ) );
				vec4 west = texture2D( heightmap, uv + vec2( - cellSize.x, 0.0 ) );
				// https://web.archive.org/web/20080618181901/http://freespace.virgin.net/hugo.elias/graphics/x_water.htm
				float newHeight = ( ( north.x + south.x + east.x + west.x ) * 0.5 - heightmapValue.y ) * viscosityConstant;

				// Ripple Sources
				float rpph0 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp0.x, - rp0.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph0 ) + 1.0 ) * 0.28;
				float rpph1 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp1.x, - rp1.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph1 ) + 1.0 ) * 0.28;
        float rpph2 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp2.x, - rp2.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph2 ) + 1.0 ) * 0.28;
        float rpph3 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp3.x, - rp3.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph3 ) + 1.0 ) * 0.28;
        float rpph4 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp4.x, - rp4.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph4 ) + 1.0 ) * 0.28;
        float rpph5 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp5.x, - rp5.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph5 ) + 1.0 ) * 0.28;
        float rpph6 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp6.x, - rp6.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph6 ) + 1.0 ) * 0.28;
        float rpph7 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp7.x, - rp7.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph7 ) + 1.0 ) * 0.28;
        float rpph8 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp8.x, - rp8.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph8 ) + 1.0 ) * 0.28;
        float rpph9 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp9.x, - rp9.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph9 ) + 1.0 ) * 0.28;
        float rpph10 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rp10.x, - rp10.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpph10 ) + 1.0 ) * 0.28;

        float rpAph0 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpA0.x, - rpA0.y ) ) * PI / mouseSize, 0.0, PI );
				newHeight += ( cos( rpAph0 ) + 1.0 ) * 0.28;

        float rpAph1 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpA1.x, - rpA1.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpAph1 ) + 1.0 ) * 0.28;
        float rpAph2 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpA2.x, - rpA2.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpAph2 ) + 1.0 ) * 0.28;
        float rpAph3 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpA3.x, - rpA3.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpAph3 ) + 1.0 ) * 0.28;
        float rpAph4 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpA4.x, - rpA4.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpAph4 ) + 1.0 ) * 0.28;
        float rpAph5 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpA5.x, - rpA5.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpAph5 ) + 1.0 ) * 0.28;
        float rpAph6 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpA6.x, - rpA6.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpAph6 ) + 1.0 ) * 0.28;
        float rpAph7 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpA7.x, - rpA7.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpAph7 ) + 1.0 ) * 0.28;
        float rpAph8 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpA8.x, - rpA8.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpAph8 ) + 1.0 ) * 0.28;
        float rpAph9 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpA9.x, - rpA9.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpAph9 ) + 1.0 ) * 0.28;
        float rpAph10 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpA10.x, - rpA10.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpAph10 ) + 1.0 ) * 0.28;

        float rpBph0 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpB0.x, - rpB0.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpBph0 ) + 1.0 ) * 0.28;
        float rpBph1 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpB1.x, - rpB1.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpBph1 ) + 1.0 ) * 0.28;
        float rpBph2 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpB2.x, - rpB2.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpBph2 ) + 1.0 ) * 0.28;
        float rpBph3 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpB3.x, - rpB3.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpBph3 ) + 1.0 ) * 0.28;
        float rpBph4 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpB4.x, - rpB4.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpBph4 ) + 1.0 ) * 0.28;
        float rpBph5 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpB5.x, - rpB5.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpBph5 ) + 1.0 ) * 0.28;
        float rpBph6 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpB6.x, - rpB6.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpBph6 ) + 1.0 ) * 0.28;
        float rpBph7 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpB7.x, - rpB7.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpBph7 ) + 1.0 ) * 0.28;
        float rpBph8 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpB8.x, - rpB8.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpBph8 ) + 1.0 ) * 0.28;
        float rpBph9 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpB9.x, - rpB9.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpBph9 ) + 1.0 ) * 0.28;
        float rpBph10 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpB10.x, - rpB10.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpBph10 ) + 1.0 ) * 0.28;

        float rpCph0 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpC0.x, - rpC0.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpCph0 ) + 1.0 ) * 0.28;
        float rpCph1 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpC1.x, - rpC1.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpCph1 ) + 1.0 ) * 0.28;
        float rpCph2 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpC2.x, - rpC2.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpCph2 ) + 1.0 ) * 0.28;
        float rpCph3 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpC3.x, - rpC3.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpCph3 ) + 1.0 ) * 0.28;
        float rpCph4 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpC4.x, - rpC4.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpCph4 ) + 1.0 ) * 0.28;
        float rpCph5 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpC5.x, - rpC5.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpCph5 ) + 1.0 ) * 0.28;
        float rpCph6 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpC6.x, - rpC6.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpCph6 ) + 1.0 ) * 0.28;
        float rpCph7 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpC7.x, - rpC7.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpCph7 ) + 1.0 ) * 0.28;
        float rpCph8 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpC8.x, - rpC8.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpCph8 ) + 1.0 ) * 0.28;
        float rpCph9 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpC9.x, - rpC9.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpCph9 ) + 1.0 ) * 0.28;
        float rpCph10 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpC10.x, - rpC10.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpCph10 ) + 1.0 ) * 0.28;

        float rpgph0 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpg0.x, - rpg0.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgph0 ) + 1.0 ) * 0.28;
        float rpgph1 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpg1.x, - rpg1.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgph1 ) + 1.0 ) * 0.28;
        float rpgph2 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpg2.x, - rpg2.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgph2 ) + 1.0 ) * 0.28;
        float rpgph3 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpg3.x, - rpg3.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgph3 ) + 1.0 ) * 0.28;
        float rpgph4 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpg4.x, - rpg4.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgph4 ) + 1.0 ) * 0.28;
        float rpgph5 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpg5.x, - rpg5.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgph5 ) + 1.0 ) * 0.28;
        float rpgph6 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpg6.x, - rpg6.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgph6 ) + 1.0 ) * 0.28;
        float rpgph7 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpg7.x, - rpg7.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgph7 ) + 1.0 ) * 0.28;
        float rpgph8 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpg8.x, - rpg8.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgph8 ) + 1.0 ) * 0.28;
        float rpgph9 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpg9.x, - rpg9.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgph9 ) + 1.0 ) * 0.28;
        float rpgph10 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpg10.x, - rpg10.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgph10 ) + 1.0 ) * 0.28;

        float rpgAph0 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgA0.x, - rpgA0.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgAph0 ) + 1.0 ) * 0.28;
        float rpgAph1 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgA1.x, - rpgA1.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgAph1 ) + 1.0 ) * 0.28;
        float rpgAph2 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgA2.x, - rpgA2.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgAph2 ) + 1.0 ) * 0.28;
        float rpgAph3 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgA3.x, - rpgA3.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgAph3 ) + 1.0 ) * 0.28;
        float rpgAph4 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgA4.x, - rpgA4.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgAph4 ) + 1.0 ) * 0.28;
        float rpgAph5 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgA5.x, - rpgA5.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgAph5 ) + 1.0 ) * 0.28;
        float rpgAph6 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgA6.x, - rpgA6.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgAph6 ) + 1.0 ) * 0.28;
        float rpgAph7 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgA7.x, - rpgA7.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgAph7 ) + 1.0 ) * 0.28;
        float rpgAph8 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgA8.x, - rpgA8.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgAph8 ) + 1.0 ) * 0.28;
        float rpgAph9 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgA9.x, - rpgA9.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgAph9 ) + 1.0 ) * 0.28;
        float rpgAph10 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgA10.x, - rpgA10.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgAph10 ) + 1.0 ) * 0.28;

        float rpgBph0 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgB0.x, - rpgB0.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgBph0 ) + 1.0 ) * 0.28;
        float rpgBph1 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgB1.x, - rpgB1.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgBph1 ) + 1.0 ) * 0.28;
        float rpgBph2 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgB2.x, - rpgB2.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgBph2 ) + 1.0 ) * 0.28;
        float rpgBph3 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgB3.x, - rpgB3.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgBph3 ) + 1.0 ) * 0.28;
        float rpgBph4 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgB4.x, - rpgB4.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgBph4 ) + 1.0 ) * 0.28;
        float rpgBph5 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgB5.x, - rpgB5.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgBph5 ) + 1.0 ) * 0.28;
        float rpgBph6 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgB6.x, - rpgB6.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgBph6 ) + 1.0 ) * 0.28;
        float rpgBph7 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgB7.x, - rpgB7.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgBph7 ) + 1.0 ) * 0.28;
        float rpgBph8 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgB8.x, - rpgB8.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgBph8 ) + 1.0 ) * 0.28;
        float rpgBph9 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgB9.x, - rpgB9.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgBph9 ) + 1.0 ) * 0.28;
        float rpgBph10 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgB10.x, - rpgB10.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgBph10 ) + 1.0 ) * 0.28;

        float rpgCph0 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgC0.x, - rpgC0.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgCph0 ) + 1.0 ) * 0.28;
        float rpgCph1 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgC1.x, - rpgC1.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgCph1 ) + 1.0 ) * 0.28;
        float rpgCph2 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgC2.x, - rpgC2.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgCph2 ) + 1.0 ) * 0.28;
        float rpgCph3 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgC3.x, - rpgC3.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgCph3 ) + 1.0 ) * 0.28;
        float rpgCph4 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgC4.x, - rpgC4.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgCph4 ) + 1.0 ) * 0.28;
        float rpgCph5 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgC5.x, - rpgC5.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgCph5 ) + 1.0 ) * 0.28;
        float rpgCph6 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgC6.x, - rpgC6.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgCph6 ) + 1.0 ) * 0.28;
        float rpgCph7 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgC7.x, - rpgC7.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgCph7 ) + 1.0 ) * 0.28;
        float rpgCph8 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgC8.x, - rpgC8.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgCph8 ) + 1.0 ) * 0.28;
        float rpgCph9 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgC9.x, - rpgC9.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgCph9 ) + 1.0 ) * 0.28;
        float rpgCph10 = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( rpgC10.x, - rpgC10.y ) ) * PI / mouseSize, 0.0, PI );
        newHeight += ( cos( rpgCph10 ) + 1.0 ) * 0.28;


				heightmapValue.y = heightmapValue.x;
				heightmapValue.x = newHeight;

				gl_FragColor = heightmapValue;


			}

		</script>


   <!-- This is just a smoothing 'compute shader' for using manually: -->
   <script id="smoothFragmentShader" type="x-shader/x-fragment">

     uniform sampler2D smoothTexture;

			void main()	{

				vec2 cellSize = 1.0 / resolution.xy;

				vec2 uv = gl_FragCoord.xy * cellSize;

				// Computes the mean of texel and 4 neighbours
				vec4 textureValue = texture2D( smoothTexture, uv );
				textureValue += texture2D( smoothTexture, uv + vec2( 0.0, cellSize.y ) );
				textureValue += texture2D( smoothTexture, uv + vec2( 0.0, - cellSize.y ) );
				textureValue += texture2D( smoothTexture, uv + vec2( cellSize.x, 0.0 ) );
				textureValue += texture2D( smoothTexture, uv + vec2( - cellSize.x, 0.0 ) );

				textureValue /= 5.0;

				gl_FragColor = textureValue;

			}

		</script>

   <!-- This is a 'compute shader' to read the current level and normal of water at a point -->
   <!-- It is used with a variable of size 1x1 -->
   <script id="readWaterLevelFragmentShader" type="x-shader/x-fragment">

     uniform vec2 point1;

			uniform sampler2D levelTexture;

			// Integer to float conversion from https://stackoverflow.com/questions/17981163/webgl-read-pixels-from-floating-point-render-target

			float shift_right( float v, float amt ) {

				v = floor( v ) + 0.5;
				return floor( v / exp2( amt ) );

			}

			float shift_left( float v, float amt ) {

				return floor( v * exp2( amt ) + 0.5 );

			}

			float mask_last( float v, float bits ) {

				return mod( v, shift_left( 1.0, bits ) );

			}

			float extract_bits( float num, float from, float to ) {

				from = floor( from + 0.5 ); to = floor( to + 0.5 );
				return mask_last( shift_right( num, from ), to - from );

			}

			vec4 encode_float( float val ) {
				if ( val == 0.0 ) return vec4( 0, 0, 0, 0 );
				float sign = val > 0.0 ? 0.0 : 1.0;
				val = abs( val );
				float exponent = floor( log2( val ) );
				float biased_exponent = exponent + 127.0;
				float fraction = ( ( val / exp2( exponent ) ) - 1.0 ) * 8388608.0;
				float t = biased_exponent / 2.0;
				float last_bit_of_biased_exponent = fract( t ) * 2.0;
				float remaining_bits_of_biased_exponent = floor( t );
				float byte4 = extract_bits( fraction, 0.0, 8.0 ) / 255.0;
				float byte3 = extract_bits( fraction, 8.0, 16.0 ) / 255.0;
				float byte2 = ( last_bit_of_biased_exponent * 128.0 + extract_bits( fraction, 16.0, 23.0 ) ) / 255.0;
				float byte1 = ( sign * 128.0 + remaining_bits_of_biased_exponent ) / 255.0;
				return vec4( byte4, byte3, byte2, byte1 );
			}

			void main()	{

				vec2 cellSize = 1.0 / resolution.xy;

				float waterLevel = texture2D( levelTexture, point1 ).x;

				vec2 normal = vec2(
					( texture2D( levelTexture, point1 + vec2( - cellSize.x, 0 ) ).x - texture2D( levelTexture, point1 + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
					( texture2D( levelTexture, point1 + vec2( 0, - cellSize.y ) ).x - texture2D( levelTexture, point1 + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS );

				if ( gl_FragCoord.x < 1.5 ) {

					gl_FragColor = encode_float( waterLevel );

				} else if ( gl_FragCoord.x < 2.5 ) {

					gl_FragColor = encode_float( normal.x );

				} else if ( gl_FragCoord.x < 3.5 ) {

					gl_FragColor = encode_float( normal.y );

				} else {

					gl_FragColor = encode_float( 0.0 );

				}

			}

		</script>

   <!-- This is the water visualization shader, copied from the THREE.MeshPhongMaterial and modified: -->
   <script id="waterVertexShader" type="x-shader/x-vertex">

     uniform sampler2D heightmap;

			#define PHONG

			varying vec3 vViewPosition;

			#ifndef FLAT_SHADED

				varying vec3 vNormal;

			#endif

			#include <common>
			#include <uv_pars_vertex>
			#include <uv2_pars_vertex>
			#include <displacementmap_pars_vertex>
			#include <envmap_pars_vertex>
			#include <color_pars_vertex>
			#include <morphtarget_pars_vertex>
			#include <skinning_pars_vertex>
			#include <shadowmap_pars_vertex>
			#include <logdepthbuf_pars_vertex>
			#include <clipping_planes_pars_vertex>

			void main() {

				vec2 cellSize = vec2( 1.0 / WIDTH, 1.0 / WIDTH );

				#include <uv_vertex>
				#include <uv2_vertex>
				#include <color_vertex>

				// # include <beginnormal_vertex>
				// Compute normal from heightmap
				vec3 objectNormal = vec3(
					( texture2D( heightmap, uv + vec2( - cellSize.x, 0 ) ).x - texture2D( heightmap, uv + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
					( texture2D( heightmap, uv + vec2( 0, - cellSize.y ) ).x - texture2D( heightmap, uv + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS,
					1.0 );
				//<beginnormal_vertex>

				#include <morphnormal_vertex>
				#include <skinbase_vertex>
				#include <skinnormal_vertex>
				#include <defaultnormal_vertex>

			#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

				vNormal = normalize( transformedNormal );

			#endif

				//# include <begin_vertex>
				float heightValue = texture2D( heightmap, uv ).x;
				vec3 transformed = vec3( position.x, position.y, heightValue );
				//<begin_vertex>

				#include <morphtarget_vertex>
				#include <skinning_vertex>
				#include <displacementmap_vertex>
				#include <project_vertex>
				#include <logdepthbuf_vertex>
				#include <clipping_planes_vertex>

				vViewPosition = - mvPosition.xyz;

				#include <worldpos_vertex>
				#include <envmap_vertex>
				#include <shadowmap_vertex>

			}

		</script>


   <script type="module">
      import * as THREE from '../build/three.module.js';
		  import { GPUComputationRenderer } from './jsm/misc/GPUComputationRenderer.js';
			import { SimplexNoise } from './jsm/math/SimplexNoise.js';
      // GLOBAL VARIABLES ------------------------------------- //
      //TIMING & ANIMATION ENGINE /////////////
      var frmRate = 60.0;
      var framect = 0;
      var delta = 0.0;
      var lastFrameTimeMs = 0.0;
      var timestep = 1000.0 / frmRate;
      var pieceClock = 0.0;
      var clockadj = 0.0;
      var timeToGo = 3.0;
      var pxPerSec = 100.0;
      var pxPerFrame = pxPerSec / frmRate;
      var pxPerMs = pxPerSec / 1000.0;
      //COLORS /////////////////////////////////
      var clr_limegreen = new THREE.Color("rgb(153, 255, 0)");
      var clr_yellow = new THREE.Color("rgb(255, 255, 0)");
      var clr_orange = new THREE.Color("rgb(255, 128, 0)");
      var clr_red = new THREE.Color("rgb(255, 0, 0)");
      var clr_purple = new THREE.Color("rgb(255, 0, 255)");
			// Texture width for simulation
      var WIDTH = 196;
			// Water size in system units
      var BOUNDS = 512;
      var BOUNDSL = 512;
			var BOUNDS_HALF = BOUNDS * 0.5;

      var CW = 560;
      var CH = 520;

			var container;
			var camera, scene, renderer;

			var waterMesh;
			var gpuCompute;
			var heightmapVariable;
			var waterUniforms;
			var smoothShader;
			var readWaterLevelShader;
			var readWaterLevelRenderTarget;
			var readWaterLevelImage;
			var waterNormal = new THREE.Vector3();
			var simplex = new SimplexNoise();
      //GO FRETS ///////////////////////////////
      var gofretposx = -120;
      var gofretposz = 227;
      //TEMPO FRETS ///////////////////////////////
      var gofret1, tfbgeom, tfbmatl, gofretborder;
      var tfs = [];
      var gofretTimer = 0;
      var tfgeom = new THREE.CubeGeometry(30, 60, 5);
      var gofretGeomBig = new THREE.CubeGeometry(30, 64, 13);
      var tfbgeom = new THREE.EdgesGeometry(tfgeom);
      var tfbgeomBig = new THREE.EdgesGeometry(gofretGeomBig);
      var gfmatl = new THREE.MeshBasicMaterial({
        color: "rgb(255,255,0)"
      });
      var tfmatl = new THREE.MeshBasicMaterial({
        color: "rgb(255,128,0)"
      });

      var ges1beats = [];
      var ges1 = [];
      var gesgo1;

      // var gggeom = new THREE.CubeGeometry(25, 40, 6);
      var gggeom = new THREE.CylinderBufferGeometry(6, 6, 40, 24);
      var gggeombig = new THREE.CubeGeometry(29, 44, 10);
      var ggmatl = new THREE.MeshLambertMaterial({color: "rgb(255,128,0)"});
      var gesmatl = new THREE.MeshLambertMaterial({color: "rgb(255,0,255)"});
      var ggTimer = 0;
      var gg1, gg2, gg3, gg4;

      var aCtx;

			init();
      requestAnimationFrame(mainLoop);

			function init() {
        aCtx = new(window.AudioContext || window.webkitAudioContext)();
        container = document.getElementById('tlcanvas');
        camera = new THREE.PerspectiveCamera( 75, CW / CH, 1, 3000 );
        camera.position.set( 0, 350, 350 );
        camera.rotation.x = rads(-48);

				scene = new THREE.Scene();

				var sun = new THREE.DirectionalLight( 0xFFFFFF, 1.0 );
				sun.position.set( 300, 400, 175 );
				scene.add( sun );

				var sun2 = new THREE.DirectionalLight( 0x40A040, 0.6 );
				sun2.position.set( - 100, 350, - 200 );
				scene.add( sun2 );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( CW, CH );
				container.appendChild( renderer.domElement );

				initWater();

        // Back Plane
        var planeMaterial =
          new THREE.MeshLambertMaterial({
            color: 0x0040C0
          });
        var plane = new THREE.Mesh(
          new THREE.PlaneGeometry(
            512,
            800,
            10,
            10
          ),
          planeMaterial
        );
        plane.position.z = -640;
        plane.rotation.x = -90 * Math.PI / 180;
        scene.add(plane);
        //TRACKS ///////////////////////////////////////////
        var cygeom = new THREE.CylinderGeometry(5, 5, 1200, 32);
        var cymatl = new THREE.MeshLambertMaterial({color: 0x708090});
        var cy1 = new THREE.Mesh(cygeom, cymatl);
        var cy2 = new THREE.Mesh(cygeom, cymatl);
        var cy3 = new THREE.Mesh(cygeom, cymatl);
        var cy4 = new THREE.Mesh(cygeom, cymatl);
        cy1.rotation.x = -90 * Math.PI / 180;
        cy1.position.z = -346;
        cy2.rotation.x = -90 * Math.PI / 180;
        cy2.position.z = -346;
        cy1.position.x = -40;
        cy2.position.x = 40;
        cy3.rotation.x = -90 * Math.PI / 180;
        cy3.position.z = -346;
        cy4.rotation.x = -90 * Math.PI / 180;
        cy4.position.z = -346;
        cy3.position.x = -120;
        cy4.position.x = 120;
        scene.add(cy1);
        scene.add(cy2);
        scene.add(cy3);
        scene.add(cy4);
        //GO FRETS ///////////////////////////////////////////
        gofret1 = new THREE.Mesh(tfgeom, gfmatl);
        gofret1.position.x = -120;
        gofret1.position.z = gofretposz;
        gofret1.rotation.z = -90 * Math.PI / 180;
        scene.add(gofret1);
        var gofret2 = new THREE.Mesh(tfgeom, gfmatl);
        gofret2.position.x = -40;
        gofret2.position.z = gofretposz;
        gofret2.rotation.z = -90 * Math.PI / 180;
        scene.add(gofret2);
        var gofret3 = new THREE.Mesh(tfgeom, gfmatl);
        gofret3.position.x = 40;
        gofret3.position.z = gofretposz;
        gofret3.rotation.z = -90 * Math.PI / 180;
        scene.add(gofret3);
        var gofret4 = new THREE.Mesh(tfgeom, gfmatl);
        gofret4.position.x = 120;
        gofret4.position.z = gofretposz;
        gofret4.rotation.z = -90 * Math.PI / 180;
        scene.add(gofret4);
        //GESTURE GO
        gg1 = new THREE.Mesh(gggeom, ggmatl);
        gg2 = new THREE.Mesh(gggeom, ggmatl);
        gg3 = new THREE.Mesh(gggeom, ggmatl);
        gg4 = new THREE.Mesh(gggeom, ggmatl);
        gg1.position.z = gofretposz;
        gg1.position.x = -120;
        scene.add(gg1);
        gg2.position.z = gofretposz;
        gg2.position.x = -40;
        scene.add(gg2);
        gg3.position.z = gofretposz;
        gg3.position.x = 40;
        scene.add(gg3);
        gg4.position.z = gofretposz;
        gg4.position.x = 120;
        scene.add(gg4);

        var tempo = 85.0;
        var pxPerBeat = pxPerSec / (tempo / 60);
        //GESTURES
        ges1beats = [ [0, 5], [0, 6], [0, 7], [0, 8], [0, 9], [0, 10], [0, 11], [1, 8.9] ];
        for (var i = 0; i < ges1beats.length; i++) {
          var ges = new THREE.Mesh(gggeom, gesmatl);
          var startpx, goframe;
          if(ges1beats[i][0] == 0){
            startpx = gofretposz - (pxPerBeat * ges1beats[i][1]);
            goframe = Math.round( (pxPerBeat / pxPerFrame) * ges1beats[i][1] );
          } else if (ges1beats[i][0] == 1){
            startpx = gofretposz - (pxPerSec * ges1beats[i][1]);
            goframe = Math.round( frmRate * ges1beats[i][1] );
          }
          ges.position.z = startpx;
          ges.position.x = gofretposx;
          ges.name = "ges" + i;
          var ges1ar = [true, ges, goframe];
          ges1.push(ges1ar);
        }
        // ADD TEMPO FRETS
        //given start time, tempo, #beats, get destination frame
        var itfstarttime = 0;
        var numbeats = 52;
        var durpx = itfstarttime * pxPerSec;
        var istartpx = gofretposz - durpx;
        var idurframes = durpx / pxPerFrame;
        var igoframe = Math.round(framect + idurframes);
        for (var i = 0; i < numbeats; i++) {
          //Add orange fret and move
          var tft = new THREE.Mesh(tfgeom, tfmatl);
          var startpx = istartpx - (pxPerBeat * i);
          var goframe = Math.round(igoframe + ((pxPerBeat / pxPerFrame) * i));
          tft.rotation.z = -90 * Math.PI / 180;
          tft.position.z = startpx;
          tft.position.x = gofretposx;
          tft.name = "tft" + i;

          var ntft = [true, tft, goframe];
          tfs.push(ntft);
        }

        heightmapVariable.material.uniforms[ "mouseSize" ].value = 10;
        heightmapVariable.material.uniforms[ "viscosityConstant" ].value = 0.996;

        smoothWater();
			}


			function initWater() {
				var materialColor = 0x0040C0;
				var geometry = new THREE.PlaneBufferGeometry( BOUNDS, BOUNDSL, WIDTH - 1, WIDTH - 1 );
				// material: make a THREE.ShaderMaterial clone of THREE.MeshPhongMaterial, with customized vertex shader
				var material = new THREE.ShaderMaterial( {
					uniforms: THREE.UniformsUtils.merge( [
						THREE.ShaderLib[ 'phong' ].uniforms,
						{
							"heightmap": { value: null }
						}
					] ),
					vertexShader: document.getElementById( 'waterVertexShader' ).textContent,
					fragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]

				} );
				material.lights = true;
				// Material attributes from THREE.MeshPhongMaterial
				material.color = new THREE.Color( materialColor );
				material.specular = new THREE.Color( 0x111111 );
				material.shininess = 50;
				// Sets the uniforms with the material values
				material.uniforms[ "diffuse" ].value = material.color;
				material.uniforms[ "specular" ].value = material.specular;
				material.uniforms[ "shininess" ].value = Math.max( material.shininess, 1e-4 );
				material.uniforms[ "opacity" ].value = material.opacity;
				// Defines
				material.defines.WIDTH = WIDTH.toFixed( 1 );
				material.defines.BOUNDS = BOUNDS.toFixed( 1 );
				material.defines.BOUNDSL = BOUNDSL.toFixed( 1 );
				waterUniforms = material.uniforms;
				waterMesh = new THREE.Mesh( geometry, material );
				waterMesh.rotation.x = - Math.PI / 2;
				waterMesh.matrixAutoUpdate = false;
				waterMesh.updateMatrix();
				scene.add( waterMesh );
				// Creates the gpu computation class and sets it up
				gpuCompute = new GPUComputationRenderer( WIDTH, WIDTH, renderer );
				var heightmap0 = gpuCompute.createTexture();
				fillTexture( heightmap0 );
				heightmapVariable = gpuCompute.addVariable( "heightmap", document.getElementById( 'heightmapFragmentShader' ).textContent, heightmap0 );
				gpuCompute.setVariableDependencies( heightmapVariable, [ heightmapVariable ] );
				heightmapVariable.material.uniforms[ "rp0" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp1" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp2" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp3" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp4" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp5" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp6" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp7" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp8" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp9" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rp10" ] = { value: new THREE.Vector2( 10000, 10000 ) };
        heightmapVariable.material.uniforms[ "rpA0" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpA1" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpA2" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpA3" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpA4" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpA5" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpA6" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpA7" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpA8" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpA9" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpA10" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpB0" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpB1" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpB2" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpB3" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpB4" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpB5" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpB6" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpB7" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpB8" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpB9" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpB10" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpC0" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpC1" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpC2" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpC3" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpC4" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpC5" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpC6" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpC7" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpC8" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpC9" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpC10" ] = { value: new THREE.Vector2( 10000, 10000 ) };

				heightmapVariable.material.uniforms[ "rpg0" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpg1" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpg2" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpg3" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpg4" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpg5" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpg6" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpg7" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpg8" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpg9" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpg10" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgA0" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgA1" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgA2" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgA3" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgA4" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgA5" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgA6" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgA7" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgA8" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgA9" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgA10" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgB0" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgB1" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgB2" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgB3" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgB4" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgB5" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgB6" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgB7" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgB8" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgB9" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgB10" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgC0" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgC1" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgC2" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgC3" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgC4" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgC5" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgC6" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgC7" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgC8" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgC9" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "rpgC10" ] = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms[ "mouseSize" ] = { value: 20.0 };
				heightmapVariable.material.uniforms[ "viscosityConstant" ] = { value: 0.98 };
				heightmapVariable.material.uniforms[ "heightCompensation" ] = { value: 0 };
				heightmapVariable.material.defines.BOUNDS = BOUNDS.toFixed( 1 );
				heightmapVariable.material.defines.BOUNDSL = BOUNDSL.toFixed( 1 );
				var error = gpuCompute.init();
				if ( error !== null ) {
				    console.error( error );
				}
				// Create compute shader to smooth the water surface and velocity
				smoothShader = gpuCompute.createShaderMaterial( document.getElementById( 'smoothFragmentShader' ).textContent, { smoothTexture: { value: null } } );
				// Create compute shader to read water level
				readWaterLevelShader = gpuCompute.createShaderMaterial( document.getElementById( 'readWaterLevelFragmentShader' ).textContent, {
					point1: { value: new THREE.Vector2() },
					levelTexture: { value: null }
				} );
				readWaterLevelShader.defines.WIDTH = WIDTH.toFixed( 1 );
				readWaterLevelShader.defines.BOUNDS = BOUNDS.toFixed( 1 );
				readWaterLevelShader.defines.BOUNDSL = BOUNDSL.toFixed( 1 );
				// Create a 4x1 pixel image and a render target (Uint8, 4 channels, 1 byte per channel) to read water height and orientation
				readWaterLevelImage = new Uint8Array( 4 * 1 * 4 );
				readWaterLevelRenderTarget = new THREE.WebGLRenderTarget( 4, 1, {
					wrapS: THREE.ClampToEdgeWrapping,
					wrapT: THREE.ClampToEdgeWrapping,
					minFilter: THREE.NearestFilter,
					magFilter: THREE.NearestFilter,
					format: THREE.RGBAFormat,
					type: THREE.UnsignedByteType,
					stencilBuffer: false,
					depthBuffer: false
				} );
			}

			function fillTexture( texture ) {
				var waterMaxHeight = 10;
				function noise( x, y ) {
					var multR = waterMaxHeight;
					var mult = 0.025;
					var r = 0;
					for ( var i = 0; i < 15; i ++ ) {
						r += multR * simplex.noise( x * mult, y * mult );
						multR *= 0.53 + 0.025 * i;
						mult *= 1.25;
					}
					return r;
				}
				var pixels = texture.image.data;
				var p = 0;
				for ( var j = 0; j < WIDTH; j ++ ) {
					for ( var i = 0; i < WIDTH; i ++ ) {
						var x = i * 128 / WIDTH;
						var y = j * 128 / WIDTH;
						pixels[ p + 0 ] = noise( x, y );
						pixels[ p + 1 ] = pixels[ p + 0 ];
						pixels[ p + 2 ] = 0;
						pixels[ p + 3 ] = 1;
						p += 4;
					}
				}
			}

			function smoothWater() {
				var currentRenderTarget = gpuCompute.getCurrentRenderTarget( heightmapVariable );
				var alternateRenderTarget = gpuCompute.getAlternateRenderTarget( heightmapVariable );
				for ( var i = 0; i < 10; i ++ ) {
					smoothShader.uniforms[ "smoothTexture" ].value = currentRenderTarget.texture;
					gpuCompute.doRenderTarget( smoothShader, alternateRenderTarget );
					smoothShader.uniforms[ "smoothTexture" ].value = alternateRenderTarget.texture;
					gpuCompute.doRenderTarget( smoothShader, currentRenderTarget );
				}
			}
      // ANIMATION ENGINE -------------------------------------------- //
      function mainLoop(timestamp) {
        delta += timestamp - lastFrameTimeMs;
        lastFrameTimeMs = timestamp;
        while (delta >= timestep) {
          update(timestep);
          delta -= timestep;
        }
        render();
        requestAnimationFrame(mainLoop);
      }

			function render() {
          // Set uniforms: mouse interaction
          var uniforms = heightmapVariable.material.uniforms;
          for(var i=0;i<tfs.length;i++){
            if(tfs[i][1].position.z > -256){
              if(i<11){
                var rpname = "rp" + i;
                uniforms[ rpname ].value.set(-120, tfs[i][1].position.z );
              }
            }
          }
  				gpuCompute.compute();
  				waterUniforms[ "heightmap" ].value = gpuCompute.getCurrentRenderTarget( heightmapVariable ).texture;
  				renderer.render( scene, camera );
			}

      // UPDATE ------------------------------------------------------ //
      function update(timestep) {
        framect++;
        //Clock //////////////////////////////////
        pieceClock += timestep;
        pieceClock = pieceClock - clockadj;
        //Tempo FRETS /////////////////////////////
        for (var i = 0; i < tfs.length; i++) { //if it has not reached go fret
          if (tfs[i][1].position.z < gofretposz) {
            tfs[i][1].position.z += pxPerFrame;
          }
          //add the tf to the scene if it is in the scene
          if (tfs[i][1].position.z > -1000) {
            if (tfs[i][0]) { //gate so the tf is only added to the scene once
              tfs[i][0] = false;
              scene.add(tfs[i][1]);
            }
          }
          if (framect == tfs[i][2]) { //when the tf reaches its destination frame
            // set gofretTimer so it blinks clr_limegreen
            gofretTimer = framect + 12;
            //remove tf from scene and array
            scene.remove(scene.getObjectByName(tfs[i][1].name));
            tfs.splice(i, 1);
          }
        }
        //Gestures /////////////////////////////
        for (var i = 0; i < ges1.length; i++) { //if it has not reached go fret
          if (ges1[i][1].position.z < gofretposz) {
            ges1[i][1].position.z += pxPerFrame;
          }
          //add the tf to the scene if it is in the scene
          if (ges1[i][1].position.z > -1000) {
            if (ges1[i][0]) { //gate so the tf is only added to the scene once
              ges1[i][0] = false;
              scene.add(ges1[i][1]);
            }
          }
          if (framect == ges1[i][2]) { //when the tf reaches its destination frame
            // set gofretTimer so it blinks clr_limegreen
            ggTimer = framect + 11;
            playsamp("/samples/violin-pizz-nonvib-g5.wav");
            //remove tf from scene and array
            scene.remove(scene.getObjectByName(ges1[i][1].name));
            ges1.splice(i, 1);
          }
        }
        //GESTURE GO  /////////////////////////////////
      if (framect >= ggTimer) {
        gg1.material.color = clr_purple;
        gg1.geometry = gggeom;
      }
      else {
        gg1.material.color = clr_red;
        gg1.geometry = gggeombig;
      }
        //GO FRET /////////////////////////////////
        if (framect >= gofretTimer) {
          gofret1.material.color = clr_yellow;
          gofret1.geometry = tfgeom;
        } else {
          gofret1.material.color = clr_limegreen;
          gofret1.geometry = gofretGeomBig;
        }
      }

      function rads(deg) {
        return (deg * Math.PI) / 180;
      }

      function map_range(value, low1, high1, low2, high2) {
        return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
      }
      function playsamp(sampname) {
        // Create a buffer for the incoming sound content
        var source = aCtx.createBufferSource();
        // Create the XHR which will grab the audio contents
        var request = new XMLHttpRequest();
        // Set the audio file src here
        request.open('GET', sampname, true);
        // Setting the responseType to arraybuffer sets up the audio decoding
        request.responseType = 'arraybuffer';
        request.onload = function() {
          // Decode the audio once the require is complete
          aCtx.decodeAudioData(request.response, function(buffer) {
            source.buffer = buffer;
            // Connect the audio to source (multiple audio buffers can be connected!)
            source.connect(aCtx.destination);
            // Simple setting for the buffer
            source.loop = false;
            source.playbackRate.value = 1;
            source.start(1);

          }, function(e) {
            console.log('Audio error! ', e);
          });
        }
        // Send the request which kicks off
        request.send();
      }

		</script>
 </body>

 </html>
 <!--
 Figure out to schedule gestures by beat and absolute time
 Change Notes
 Multiple Parts
 Multiple Tempi
 Tempo Flags
  -->
